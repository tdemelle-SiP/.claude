UNICODE EMOJIS

⚫⚪🟣🟤🟠🔴🟡🟢🔵   🟪🟩🟨🟥🟫🟧🟦⬜⬛   💚💙💜💛🖤🧡🤎🤍🩵🩷🩶❤❤️‍🔥💔

🔼 🔽 ▶ ◀ ⏩ ⏪ ⏫ ⏬ ⏺ ⏹   ➡ ⬅ ⬆ ⬇ ❌ ↩ ↪ ⤵ ⤴   ✅ ⚠️ ⏳ 🛠️ 🚀 📊

❌ ✔ ⭕ ⚜ ☑ 🔱 ❗ ‼ ❓ ⁉ ➕ ✖ ➖ 🔅 🔆   ⛔ 🚫 ☢ ☣ ⚠   💡 🔎 💰 🪙   📦 ✏ 📝   📌 📍 📁 📂 🗑

🔓 🔒 🔑   ⚙ ⛓️‍💥 🔗

🌙 🌟 🔥 ⚡ ☀ ❄ ⭐   🌏 🌎 🌍 🌐   🚧 🛑 ⚓ 🛟 🛎 🕑   ♣ ♥ ♦ ♠ ♟

🧵 🫧 🗿 🎁 ✨ 🏆 🔮 🪩 🧩 🎯 ❌ 🕹 🎨 🖼 🏛 🏠 🏰 🏢 🏦 ⛩

🍺 🏺   🪽 🕸 🐛 🍀 🍁   ✋ 👌 👉 👍 👀 👣 👾 💥

📝File...

		🚀Loading Dashboard Section...

		⏳Registering...
		Registered⏳.

		🛠️Initializing...
		Ready🛠️.

		❌Refreshing...

		👉Calling...
			🧩Data:

		⚡Running...
		Run⚡.

		Dashboard Section Loaded.
'🖧backend',
'💻frontend',
'⛩main',
'🌐ajax',
🌐➖➖➖🌐➖➖➖🌐➖➖➖🌐➖➖➖🌐
'🟢productActions',
🟢➖➖➖🟢➖➖➖🟢➖➖➖🟢➖➖➖🟢
'❌imageActions',
❌➖➖➖❌➖➖➖❌➖➖➖❌➖➖➖❌
'🔵templateActions',
🔵➖➖➖🔵➖➖➖🔵➖➖➖🔵➖➖➖🔵
'🟡creationTableActions',
🟡➖➖➖🟡➖➖➖🟡➖➖➖🟡➖➖➖🟡
'💰shopActions',
💰➖➖➖💰➖➖➖💰➖➖➖💰➖➖➖💰
'📝jsonEditorActions',
'📁catalogImages',
'❌syncProductsToShop',
'🚧creationTableSetupActions',
'🛠️utilities'

====================================================================================
=========                    THE CURRENT DRAWING BOARD       	           =========
====================================================================================

RUN BVTS TIL CLEAN

PRODUCT/CHILD PRODUCT/TEMPLATE HYGIENE
On shop creation and on reload shop products:

CHECK TO MAKE SURE THAT PRODUCTS ARE RECONCILED AGAINST EXISTING TEMPLATES
-Create Logic that organizes products in the product table into parent/child relationships and that validates that the loaded template reflects the state of the product table.
	-If there are templates in data
		-for each template,
			CHECK SOURCE PRODUCT TITLE AND ID
					-If there is a match in the loaded products, set the product/s to status "parent product".
					-If there is not a match in the loaded products, set the template status to "orphan" in the template table.
			CHECK COPIES ARRAYS
					-If there is a product with a matching child_product_title, set the product/s to status "child product" in the product table and nest them under their parent product.
					-If there is not a match in the loaded products, set the child product status to "orphan" in the copies array.

IF A NEW PRODUCT IS MADE INTO A TEMPLATE
CHECK TO SEE IF OTHER PRODUCTS SHOULD BE CLASSIFIED AS CHILDREN AND ADDED TO THE COPIES ARRAY OF THE NEW TEMPLATE
	-


====================================================================================
=========                             TO DO                                =========
====================================================================================
-Work on Product Creation Table Actions

NEED TO REVIEW AJAX CALLS TO MAKE SURE THEY 
	ARE USING THE UNIVERSAL DATATABLE RESPONSE FUNCTION IN AJAX-FUNCTIONS.PHP
	ARE USING UTILITIES FORM CREATION IN ACTIONS.JS
-----

-Does a wip file update in realtime?

if a template is deleted from the template table, if it is the loaded template show a modal that warns that the loaded template will be lost.

====================================================================================
=========                            KINGDOM KEYS                          =========
====================================================================================
--------------------
INITIALIZE:
	Product Table:	window.productData
		InitializeProductDataTable()

	Image Table:	window.imageData
		initializeImageDataTable()

	Template Table:	window.masterTemplateData.table_items
		initializeTemplateDataTable()

	Creation Table:	window.creationTemplateWipData
		initializeCreationDataTable()

--------------------
AJAX CALLS:

XXXXXXXXXXXXXXXXXXXXXXXXXXXXX

25_03_31 STANDARDIZED TABLE RELOAD FUNCTIONALITY
---

function reloadProductTable(tableItems)
function reloadImageTable(tableItems)
function reloadTemplateDataTable(data)
function reloadCreationTable()

	-Reload functions depend on data that comes back from the server that is handled in the javascript success handler of whatever action was executed that requires the table to be updated.

	-The returned data is saved to Global window variables that are then used to call the reload functions

--------------------------------------
----------- CREATION TABLE -----------

The Creation Table shows the Loaded template_wip data

Loaded template_wip data exists in a couple places:
	The json file - loaded_template_wip.json - This file is created when a template is first loaded into the product creation table and persists, tracking changes made in the table, until it is closed or another template is loaded into the table replacing it.

	window.creationTemplateWipData - Client-side JavaScript Object: The window.creationTemplateWipData object in the browser - this is the data taht the javascript success handler function saves when a change is made to the creation table so that the reloadCreationTable() function can use it to update the creation table to reflect the updated table state.

---
IMPORTANT FUNCTIONS FOR THE CREATION TABLE

There are two functions that load the product creation table:
	checkAndLoadTemplateWip() - this function is used to initialize the creation table for the first time.

	reloadCreationTable() - this is the reload function that reloads the creation table when data has been updated.

---

DATA STRUCTURE
--
window.creationTemplateWipData = {
    path: "path/to/file.json",
    data: {
        template_title: "Template Title",
        // All template data here
    }
};

-------------------- THE CODE THAT UPDATES THE CREATION TABLE --------------------

		window.creationTemplateWipData = {
    			path: window.creationTemplateWipData?.path || '',
    			data: response.data.creation_template_wip_data
		};
		SiP.PrintifyManager.creationTableSetupActions.reloadCreationTable();
		

----------------------------------------------------------------------------------


----------- PRODUCT TABLE -----------

-------------------- THE CODE THAT UPDATES THE PRODUCT TABLE --------------------

                if (productTable) {
                    reloadProductTable(response.data.params.table_items);
                }

----------------------------------------------------------------------------------

----------- IMAGE TABLE -----------

-------------------- THE CODE THAT UPDATES THE IMAGE TABLE --------------------

                if (response.data.params?.table_items) {
                    reloadImageTable(response.data.params.table_items);
                }

----------------------------------------------------------------------------------

----------- TEMPLATE TABLE -----------

-------------------- THE CODE THAT UPDATES THE TEMPLATE TABLE --------------------

		reloadTemplateTable(response.data.params)

----------------------------------------------------------------------------------


XXXXXXXXXXXXXXXXXXXXXXXXXXXXX
--------------------
REFRESH:
	Product Table: reloadProductTable(tableItems)
		window.productData = products;
		reloadProductTable(products);
			--
		reloadProductTable(response.data.params.table_items);

	Image Table: reloadImageTable(data)
		reloadImageTable(response.data.params.table_items);


	Template Table: reloadTemplateTable(response.data.params)

	Creation Table: 
		instead uses initializeCreationDataTable

----------------
PATTERN FOR RELOAD FUNCTION

function reloadXxxTable(data) {
    console.log('Reloading Xxx Table');
    
    try {
        // 1. Process/normalize input data
        const processedData = processData(data);
        
        // 2. Update global data store
        window.xxxData = processedData || [];
        
        // 3. Check for empty data and handle visibility
        if (!processedData || processedData.length === 0) {
            // Show empty message, hide table
            handleEmptyData();
            return false;
        } else {
            // Hide empty message, show table
            handleDataPresent();
        }
        
        // 4. Check if table exists
        if (xxxTable) {
            // 5. Clear filters
            clearFilters();
            
            // 6. Clear and reload data
            xxxTable.clear().draw();
            xxxTable.rows.add(processedData).draw();
            
            // 7. Perform table-specific post-reload operations
            performPostReloadOperations();
            
            console.log('Xxx Table reloaded successfully');
            return true;
        } else {
            // 8. Initialize table if it doesn't exist
            console.log('Xxx Table not initialized, initializing now');
            return initializeXxxTable();
        }
    } catch (error) {
        console.error('Error reloading Xxx Table:', error);
        return false;
    }
}





--------------------
PROGRESS METER:



--------------------
JSON DATA FORMAT:


--------------------
STORAGE SCHEME:


	(The issue is that setCreationTemplateWipData sets the local variable, but getCreationTemplateWipData returns the window variable. This inconsistency is the root cause of our problems.

	Looking at product-actions.js, I can see that it uses a global variable window.productData directly, not through a getter/setter pattern:

	data: window.productData,
	And when it needs to update the data:

	window.productData = products;
	reloadProductTable(products);
	This is the cleaner, more direct approach that's consistent with the primary interfaces in the code.

	Based on this pattern, the correct solution is to:

	Remove the local variable creationTemplateWipData entirely
	Use window.creationTemplateWipData directly in the code, similar to how window.productData is used
	Remove the getCreationTemplateWipData() function entirely, or simplify it to just return window.creationTemplateWipData without any fallback
	Update setCreationTemplateWipData() to set window.creationTemplateWipData directly
	This aligns with the pattern used in product-actions.js and is cleaner and more direct.)

DATA SOURCES/STORAGE
---------
SOURCES
	PRINTIFY
		Products: API Call
		Images: API Call
		Blueprints: API Call
	USER INPUT
		Templates: created in Product Table from Products
		Child Products: created in Product Creation Table from a Template
		Images: uploaded
STORAGE
---
	JSON FILES
		Products: \wp-content\uploads\sip-printify-manager\products\*.json
		Templates: \wp-content\uploads\sip-printify-manager\templates\*_template.json
		Child Products:
			template.json: \wp-content\uploads\sip-printify-manager\templates\*_template.json
			template_wip.json: \wp-content\uploads\sip-printify-manager\templates\*_template_wip.json
	IMAGE FILES
		Local Images: \wp-content\uploads\sip-printify-manager\images\
		Thumbnails: \wp-content\uploads\sip-printify-manager\images\thumbnails\
		Printify urls
	SQL DATABASE
		WP_OPTIONS
		WP_SIP_PRINTIFY_MANAGER
		
	LOCALSTORAGE
		SIP-CORE
		    sip-printify-manager
			catalog-image-index
				scrollPosition:
				searchField: ""
				sortOrder:
				view:
			creations-table
				actionDropdown
				isDirty
				loaded-wip
				loaded-wip-is-dirty
				loadedWipIsDirty
				templateFile:
				wipFilename:
			images-table
				actionDropdown:
			main-window
				scrollPosition:
			products-table
				actionDropdown:
			products-tables
				actionDropdown:
			template-json-editor
				descriptionWindow:
				jsonWindow:
				modal:
			templates-table
				actionDropdown:
		CREATION_DATATABLES_CREATION-TABLE
			childRows:
			columns:
			length:
			order:
			search:
			start:
			time:
		DATATABLES_IMAGE-TABLE
			columns:
			displayStart:
			order:
			search:
		IMAGE_DATATABLES_IMAGE-TABLE
			childRows:
			columns:
			length:
			order:
			search:
			select:
			start:
			time:
		PRODUCT_DATATABLES_PRODUCT-TABLE
			columns:
			length:
			order:
			search:
			select:
			start:
			time:
		TEMPLATE_DATATABLES_TEMPLATE-TABLE
			columns:
			length:
			order:
			search:
			select:
			start:
			time:

	WINDOW

====================================================================================
=========                            POLISH                                =========
====================================================================================

-style images table section when there's nothing loaded
from hand written note - rename function "single image"

Product Creation Table is showing up on the shop token entry page

-consider defaulting the image table to alphabetical by filename

have the create name option toggled on by default when Add to New Product progress dialogue is first opened

Template Table Modification
Add thumbnail column with the thumbnail of the source product

Images Table Modification
Add thumbnail Column that shows the thumbnail of the loaded template IF the image row is highlighted.

fix prices in variant rows. no --
-- instead of variant in type column in variant rows

Add notification that templates and local images will be preserved.  perhaps allow them to be deleted optionally on clear shop.  Perhaps show them on shop authorization screen?  Maybe that's where the codemirror json editor makes sense???


====================================================================================
=========                           CLEANUP                                =========
====================================================================================

update_child_product_data()
edit_child_product()
multiple sortrows needing to be integrated?

FUNCTION AUDIT - redundancy? opportunities for efficiencies?  create clear naming, establish clarity of function AND structure


====================================================================================
=========                           COULD DO                               =========
====================================================================================

codemirror extensions to add:
	history provides an undo/redo history.
	search configures the search panel.
	scrollPastEnd allows the user to scroll down until the last line is at the top of the viewport.
	highlightSelectionMatches highlights instances of the currently selected text.
	lineNumbers adds a line number gutter to the side of the editor.
	lintGutter lists lint errors beside the lines in which they occur.
	dropCursor shows a pseudo-cursor at the current drop point when the user drags content over the editor.
	Extension Bundles??  https://codemirror.net/docs/ref/#codemirror.basicSetup

Bulk Iags, Categories solution

mockups solution

Add an opening page that has some overview information that then has a button that opens the add shop token page.
-add header like the Product Creation Table Header
- maybe add a tab so you can interact with your store in an embedded browser

LIFECYCLES
		Child Product status - Child product status is reflected in the child product row's status cell in the product creation table, the status header in the product creation table, the count in that status header, in the status header in the image table, the count in that status header and in the color of the highlight in the image table assigned to the images referenced in the child product.  
	Child Product Status Life Cycle:
			Work in Progress : status upon creation of Child Product
			Created : status when the child product has been uploaded to printify
			Created - Work in Progress : status when a created child product is edited in the product creation table
			Published : status when the child product has been published form printify
			Published - Work in Progress : status when a published child product is edited in the product creation table.

	Image Location - local file, printify shop

1. Multiple refresh functions with overlapping functionality:

refreshFromSavedState()
refreshLastSavedUiState()   // Redundant, combines similar logic

2. Duplicate state initialization:

initializeDashboardDefaults()
refreshDefaultUiState()     // Similar functionality

MODAL/POP-UP/DIALOG STANDARDIZATION
	save before closing
	add to new products
	upload to printify


What exactly does archive child product do?
Here's what I would expect it would do:
Change the Status to Archive.  If it's a published product, the unpublish product API call should be sent to printify.
POST /v1/shops/{shop_id}/products/{product_id}/unpublish.json
Notify that a product has been unpublished
is there a way to check if a product loaded from printify is or could be a child product of the loaded template?


2. Create a unified comparison function:

function compareValues(a, b, type) {
    const comparators = {
        pixels: (a, b) => a.split('x').reduce((x, y) => parseInt(x) * parseInt(y), 1) - 
                         b.split('x').reduce((x, y) => parseInt(x) * parseInt(y), 1),
        fileSize: (a, b) => convertToBytes(a) - convertToBytes(b),
        date: (a, b) => parseCustomDate(b) - parseCustomDate(a)
    };
    return comparators[type](a, b);
}


3. Multiple sorting comparison functions that could be consolidated:

comparePixels()
compareFileSize()
compareDates()


Create a central event management system:

const eventHandlers = {
    dashboard: new Map(),
    imageTable: new Map(),
    creationTable: new Map()
};

function bindEventHandler(category, element, event, handler) {
    if (!eventHandlers[category].has(element)) {
        eventHandlers[category].set(element, new Map());
    }
    eventHandlers[category].get(element).set(event, handler);
    $(element).on(event, handler);
}

function cleanupEventHandlers(category) {
    eventHandlers[category].forEach((handlers, element) => {
        handlers.forEach((handler, event) => {
            $(element).off(event, handler);
        });
    });
    eventHandlers[category].clear();
}


Implement a centralized state management system:

const StateManager = {
    state: {},
    
    init(initialState) {
        this.state = initialState;
        this.loadFromStorage();
    },
    
    update(path, value) {
        _.set(this.state, path, value);
        this.saveToStorage();
        this.notifyListeners(path);
    },
    
    loadFromStorage() {
        const saved = localStorage.getItem('sipDashboardState');
        if (saved) {
            this.state = {...this.state, ...JSON.parse(saved)};
        }
    },
    
    saveToStorage() {
        localStorage.setItem('sipDashboardState', JSON.stringify(this.state));
    }
};


Implement consistent error handling:

function safeOperation(operation, fallback = null) {
    try {
        return operation();
    } catch (error) {
        console.error(`Operation failed: ${error.message}`);
        return fallback;
    }
}

Reorganize the code into logical sections:

// State Management
const StateManager = { /* ... */ };

// Event Management
const EventManager = { /* ... */ };

// UI Components
const UI = {
    Spinner: { /* ... */ },
    Toast: { /* ... */ },
    ImageTable: { /* ... */ }
};

// Business Logic
const BusinessLogic = { /* ... */ };

// Utilities
const Utils = { /* ... */ };
	
implement FormData creation helper in utilities.js across the codebase



====================================================================================
=========                           LAUNCH PREP                            =========
====================================================================================

WHITE LABELING
	-stickers for packaging
	-insert for packaging
	-need to see if big acrylic can send order reciept, shipping notification and status updates using the fsgp brand.

ADD MERCH MARKET page as alternate to GALLERY
	-shows all merch
	-adapt filtering/searching
Generate the following merch for launch:
	Men's T
	Pullover Hoodie
	Coffee Mugs
	Women's T
	Kids' T
	Christmas Ornament??
	Wall Clock
	Light Cube Lamp
	Magnets
	Square Stickers
	Postcards??
	Candles
	Puzzle
	Vertical Desk Calendar
	Luggage Tag
	Keyring Tag
	Apron
	Coaster
	Jewelry Box
	Oval Necklace???
	Mouse Pad
	Hat???
	Tote Bag
	Phone Case?

====================================================================================
=========                               PERF                               =========
====================================================================================

Performance tasks - 
Database Indexing:
Ensure you have proper indexes on key columns (e.g., product IDs, category fields, attributes) to speed up queries.
Tools like EXPLAIN (in MySQL/MariaDB) help analyze query execution plans so you can determine where new or better indexes are needed.

Query Profiling & Monitoring:
Use New Relic’s APM and Query Analysis features, or database-specific tools like pt-query-digest (from Percona Toolkit) to identify slow queries.
Monitor the MySQL slow query log to pinpoint queries that degrade under heavy loads.

Caching Query Results:
Implement a server-side object cache (e.g., Redis or Memcached) with a WordPress plugin (like WP Redis or W3 Total Cache) to reduce the number of database reads.
Caching frequently accessed product data in memory significantly decreases load on the database.

 Scaling and Architecture Improvements:

Separation of Concerns:
Host your database on a separate, optimized database server (Managed DB services or dedicated DB nodes) so the web server isn’t competing for resources.
Load Balancing and Read Replicas:
If your read traffic grows significantly, consider adding a read replica database. This allows your main database to handle writes, while replicas serve read-only queries—improving scalability under high product volumes.
Cloud and Managed Solutions:
Consider managed database services (e.g., Amazon RDS, Google Cloud SQL, or DigitalOcean Managed Databases). They offer easy vertical and horizontal scaling as your site grows.

Application-Level and WordPress-Specific Tools:
WordPress Caching Plugins:
Leverage full-page caching (e.g., WP Rocket, W3 Total Cache, or Litespeed Cache) to reduce the number of dynamic queries needed to render pages with many products/images.
Object Caching and Transients:
Utilize WordPress’s built-in Transients API to store frequently used queries or product data temporarily.
A persistent object cache (Redis/Memcached) ensures this data persists between requests.
Search and Filtering Optimization:
If your product catalog is huge and searches or filters slow down, consider implementing a specialized search solution like Elasticsearch or Algolia via WordPress plugins. These offload complex queries and can scale better than MySQL alone.

CDN and Media Handling:
Content Delivery Network (CDN):
Store and serve product images from a CDN (like Cloudfront, KeyCDN, or Cloudflare) to reduce bandwidth on your server and speed up image delivery globally.
Media Offloading:
Offload media files to cloud storage (e.g., Amazon S3, Google Cloud Storage) to reduce I/O on your local server. This keeps disk usage and I/O in check as image volumes spike.

Capacity Planning and Monitoring:

Infrastructure Metrics & Alerts:
Use tools like New Relic Infrastructure and alerts to watch CPU, memory, and disk I/O on database and web servers.
Set thresholds so you’re alerted before performance degrades significantly.

Regular Load Testing:
Before adding thousands of products, run load tests (e.g., with tools like JMeter or k6) against a staging environment. Identify performance bottlenecks and fix them proactively.


evaluate and improve perf issues with the json editor modal.



====================================================================================
=========                          CHEAT SHEET                             =========
====================================================================================

//SQL QUERY TO CHECK IF THE TABLE EXISTS
	SHOW TABLES LIKE 'wp_sip_printify_products';

// SQL QUERY TO CHECK FOR PRODUCTS IN DATABASE
	SELECT COUNT(*) FROM wp_sip_printify_products;
	SELECT * FROM wp_sip_printify_products LIMIT 5;




-----------------------------

LIFECYCLE SCHEME

This scheme provides a clear lifecycle for:

	Interface - Token Entry <-> Dashboard <-> Product Creation Table <-> Json Editor
	Shop - register/clear
	Product - managed through available actions in the product table
	Template - managed through available actions in the template table, the prodoct creation table and the json editor
	Image - managed through available actions in the image table
	Child Product - managed through  available actions in the product creation table and the json editor

INITIALIZE - Build HTML, Load Data & Setup/refresh state defaults/saved state
	DashboardListeners - includes main window, product table, images table, template table, creation table UI state
	CreationTableListeners
	JsonEditorListeners
	DefaultStates

TRACK - track and record state
	DashboardState - these are the UI component states : includes main window, product table, images table, template table, creation table UI state
	LoadedTemplateState - this is data : template date should be saved permanently to the template_wip.json until saved to the main template.json file or closed without saving.  template state data should be reloaded when the template is reloaded.  This doesn't get lost when the creation table is closed, it persists with the the loadedTemplate wip data between sessions and through reloads and then, when the table is closed, if saved to the main template.json file, it persists permanently there to be recovered when the template is reloaded. 

	JsonEditorState - distinct from template_wip.json data state. When the json editor is open, changes made from it are saved to the the editor-state.json file.  The editor-state.json file is either pushed to the template_wip.json file or deleted when the json editor is closed.

REFRESH - refresh ui state on success or page reload
	DashboardState - includes main window, product table, images table, template table
	if a template is loaded, include creation table ui
	if json editor is open include JsonEditorState

RELOAD - reload .json data into Interface
	if a template is loaded, _wip.json is loaded into the creation table editor.
	if json editor is open, editor-state.json is laoded into the json editor.

CLOSE - removes loaded data from dashboard interface, saving or deleting it - close applies to loaded .json data including:
	Dashboard - on clearShop - unloads shop token, loaded products, loaded printify shop images (does not unload templates OR locally loaded images)
	LoadedTemplate - on close Creation Table - unloads template_wip.json either saving it to template.json or deleting it
	JsonEditor - on close Json Editor - unloads editor-state.json either saving it to template_wip.json or deleting it.

	🕑Printify Bearer Token: Entered by user → encrypted and stored → on shop load, used to retrieve shop data, products data, blueprints data, images data : → on reload images used to retrieve images : →on reload products used to reload products : →on publish products used to publish products, →on 

	🕑SHOP LIFECYCLE: Authenticate → Display → Interact → Close

	🕑PRODUCT LIFECYCLE: Load from Shop (Store in products sip_create_product_database sql database + json files) : → Convert to Template : → Delete Product : → Publish Product 
		check if deleting a created product deletes it from wordpress and printify
		duplicate product management through all phases

		on shop registration 
			fetch_products - fetch products
			sip_get_blueprints - fetch and store blueprints to wp options
			save_products_to_database - save products to sql database
			reload page - with token present, the dashboard loads, calling:
				sip_display_product_table
					load_products_summary
					run datatables script with loaded data

		on page load
			sip_display_product_table	
				load_products_summary
				run datatables script with loaded data

	🕑TEMPLATE LIFECYCLE: Convert from Product : → Delete Template : Load into Creation Table → Create Child Products → Add images to Child Products → Edit Child Products → Publish Child Products

	🕑IMAGE LIFECYCLE: Load from Shop or Upload Locally → Create Thumbnails → Upload Local Images to Printify → Add to Child Products
		Duplicate management

	🕑UI STATE LIFECYCLE
		image and template highlights